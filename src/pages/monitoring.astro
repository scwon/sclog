---
/**
 * 모니터링 대시보드 페이지
 * 블로그의 실시간 성능 정보를 대시보드 형태로 표시
 *
 * @description
 * - Core Web Vitals (LCP, INP, CLS) 실시간 측정
 * - 추가 성능 지표 (TTFB, FCP)
 * - 리소스 로딩 분석
 * - 네비게이션 타이밍 시각화
 */
import BaseLayout from '../layouts/BaseLayout.astro';
import Header from '../components/Header.astro';
import CoreWebVitals from '../components/monitoring/CoreWebVitals.astro';
import AdditionalMetrics from '../components/monitoring/AdditionalMetrics.astro';
import ResourceAnalysis from '../components/monitoring/ResourceAnalysis.astro';
import NavigationTiming from '../components/monitoring/NavigationTiming.astro';
---

<BaseLayout
  title="Performance Monitoring | SCLOG"
  description="SCLOG 블로그의 실시간 성능 모니터링 대시보드. Core Web Vitals, 리소스 분석, 네비게이션 타이밍을 확인하세요."
>
  <Header />
  <main class="monitoring-container">
    <header class="page-header">
      <h1 class="page-title">Performance Monitoring</h1>
      <p class="page-description">
        이 페이지의 실시간 성능 지표를 측정합니다.
        <span class="browser-note">일부 지표는 브라우저에 따라 지원되지 않을 수 있습니다.</span>
      </p>

      <!-- 성능 점수 및 실시간 상태 -->
      <div class="score-section">
        <div class="overall-score" id="overall-score">
          <div class="score-ring">
            <svg viewBox="0 0 120 120">
              <circle class="score-bg" cx="60" cy="60" r="54" />
              <circle class="score-progress" id="score-progress" cx="60" cy="60" r="54" />
            </svg>
            <div class="score-value" id="score-value">--</div>
          </div>
          <div class="score-label">Performance Score</div>
          <div class="score-status" id="score-status">측정 중...</div>
        </div>

        <div class="live-status" id="live-status">
          <div class="status-item">
            <span class="status-icon">&#9201;</span>
            <span class="status-label">체류 시간</span>
            <span class="status-value" id="session-time">0:00</span>
          </div>
          <div class="status-item" id="memory-status" style="display: none;">
            <span class="status-icon">&#128200;</span>
            <span class="status-label">JS Heap</span>
            <span class="status-value" id="memory-usage">--</span>
          </div>
          <div class="status-item">
            <span class="status-icon">&#128338;</span>
            <span class="status-label">마지막 측정</span>
            <span class="status-value" id="last-measured">--</span>
          </div>
        </div>
      </div>
    </header>

    <!-- Core Web Vitals Section -->
    <section id="core-web-vitals" class="dashboard-section">
      <CoreWebVitals />
    </section>

    <!-- Additional Metrics Section -->
    <section id="additional-metrics" class="dashboard-section">
      <AdditionalMetrics />
    </section>

    <!-- Resource Analysis Section -->
    <section id="resource-analysis" class="dashboard-section">
      <ResourceAnalysis />
    </section>

    <!-- Navigation Timing Section -->
    <section id="navigation-timing" class="dashboard-section">
      <NavigationTiming />
    </section>
  </main>
</BaseLayout>

<!-- 실시간 상태 표시 스크립트 -->
<script>
  import { formatBytes } from '../utils/performance';

  const startTime = Date.now();
  let lastMeasuredTime: number | null = null;

  /**
   * 체류 시간 업데이트
   */
  function updateSessionTime(): void {
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    const el = document.getElementById('session-time');
    if (el) {
      el.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
  }

  /**
   * 메모리 사용량 업데이트 (Chrome 전용)
   */
  function updateMemoryUsage(): void {
    const perf = performance as Performance & {
      memory?: { usedJSHeapSize: number; jsHeapSizeLimit: number };
    };

    if (perf.memory) {
      const memoryStatus = document.getElementById('memory-status');
      const memoryUsage = document.getElementById('memory-usage');

      if (memoryStatus && memoryUsage) {
        memoryStatus.style.display = 'flex';
        const used = perf.memory.usedJSHeapSize;
        memoryUsage.textContent = formatBytes(used);
      }
    }
  }

  /**
   * 마지막 측정 시간 업데이트
   */
  function updateLastMeasured(): void {
    const el = document.getElementById('last-measured');
    if (!el || !lastMeasuredTime) return;

    const ago = Math.floor((Date.now() - lastMeasuredTime) / 1000);
    if (ago < 5) {
      el.textContent = '방금';
    } else if (ago < 60) {
      el.textContent = `${ago}초 전`;
    } else {
      el.textContent = `${Math.floor(ago / 60)}분 전`;
    }
  }

  // 전역으로 마지막 측정 시간 설정 함수 노출
  (window as Window & { setLastMeasured?: () => void }).setLastMeasured = () => {
    lastMeasuredTime = Date.now();
    updateLastMeasured();
  };

  // 성능 점수 저장 및 계산
  interface MetricScores {
    lcp?: number;
    fcp?: number;
    cls?: number;
    ttfb?: number;
    inp?: number;
  }

  const metricScores: MetricScores = {};

  /**
   * 각 지표를 0-100 점수로 변환
   */
  function getMetricScore(metric: string, value: number): number {
    const thresholds: Record<string, { good: number; poor: number }> = {
      lcp: { good: 2500, poor: 4000 },
      fcp: { good: 1800, poor: 3000 },
      cls: { good: 0.1, poor: 0.25 },
      ttfb: { good: 800, poor: 1800 },
      inp: { good: 200, poor: 500 },
    };

    const t = thresholds[metric];
    if (!t) return 50;

    if (value <= t.good) {
      // good 범위: 90-100점
      return 90 + (1 - value / t.good) * 10;
    } else if (value <= t.poor) {
      // needs improvement: 50-90점
      const range = t.poor - t.good;
      const position = (value - t.good) / range;
      return 90 - position * 40;
    } else {
      // poor: 0-50점
      const beyondPoor = value - t.poor;
      const decay = Math.min(beyondPoor / t.poor, 1);
      return Math.max(0, 50 - decay * 50);
    }
  }

  /**
   * 전체 점수 계산 및 업데이트
   */
  function updateOverallScore(): void {
    const scores = Object.values(metricScores).filter((s) => s !== undefined) as number[];
    if (scores.length === 0) return;

    const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
    const score = Math.round(avg);

    // 점수 표시
    const scoreValue = document.getElementById('score-value');
    const scoreProgress = document.getElementById('score-progress');
    const scoreStatus = document.getElementById('score-status');
    const overallScore = document.getElementById('overall-score');

    if (scoreValue) scoreValue.textContent = score.toString();

    // 링 애니메이션 (둘레 = 2 * PI * 54 ≈ 339)
    if (scoreProgress) {
      const circumference = 339;
      const offset = circumference - (score / 100) * circumference;
      scoreProgress.style.strokeDasharray = `${circumference}`;
      scoreProgress.style.strokeDashoffset = `${offset}`;
    }

    // 상태 및 색상
    let status = '';
    let color = '';
    if (score >= 90) {
      status = '우수';
      color = '#0cce6b';
    } else if (score >= 50) {
      status = '개선 필요';
      color = '#ffa400';
    } else {
      status = '나쁨';
      color = '#ff4e42';
    }

    if (scoreStatus) scoreStatus.textContent = status;
    if (overallScore) overallScore.setAttribute('data-score-level', score >= 90 ? 'good' : score >= 50 ? 'average' : 'poor');
    if (scoreProgress) scoreProgress.style.stroke = color;
  }

  // 전역으로 점수 업데이트 함수 노출
  (window as Window & { updateMetricScore?: (metric: string, value: number) => void }).updateMetricScore = (metric, value) => {
    metricScores[metric as keyof MetricScores] = getMetricScore(metric, value);
    updateOverallScore();
  };

  // 1초마다 업데이트
  setInterval(() => {
    updateSessionTime();
    updateMemoryUsage();
    updateLastMeasured();
  }, 1000);

  // 초기 실행
  updateSessionTime();
  updateMemoryUsage();
</script>

<!-- 성능 지표 측정 스크립트 -->
<script>
  import { onLCP, onINP, onCLS, onTTFB, onFCP, type Metric } from 'web-vitals';
  import { getMetricStatus, type MetricId, type MetricStatus } from '../utils/performance';

  /**
   * MetricCard DOM 요소 업데이트
   */
  function updateMetricCard(
    metricId: MetricId,
    value: number,
    status: MetricStatus
  ): void {
    const card = document.querySelector(`[data-metric-id="${metricId}"]`);
    if (!card) return;

    const valueEl = card.querySelector('[data-value]');
    const statusEl = card.querySelector('[data-status]');

    if (valueEl) {
      // CLS는 소수점 3자리, 나머지는 정수
      valueEl.textContent =
        metricId === 'cls' ? value.toFixed(3) : Math.round(value).toString();
    }

    if (statusEl) {
      statusEl.setAttribute('data-status', status);
      statusEl.textContent = getStatusLabel(status);
    }
  }

  /**
   * 상태 라벨 반환
   */
  function getStatusLabel(status: MetricStatus): string {
    switch (status) {
      case 'good':
        return '좋음';
      case 'needs-improvement':
        return '개선 필요';
      case 'poor':
        return '나쁨';
      case 'pending':
        return '측정 중...';
      case 'unsupported':
        return '미지원';
      default:
        return '';
    }
  }

  /**
   * 미지원 상태로 설정
   */
  function setUnsupported(metricId: MetricId): void {
    const card = document.querySelector(`[data-metric-id="${metricId}"]`);
    if (!card) return;

    const valueEl = card.querySelector('[data-value]');
    const statusEl = card.querySelector('[data-status]');

    if (valueEl) {
      valueEl.textContent = '--';
    }

    if (statusEl) {
      statusEl.setAttribute('data-status', 'unsupported');
      statusEl.textContent = '미지원';
    }
  }

  /**
   * INP 대기 상태로 설정
   */
  function setInpWaiting(): void {
    const card = document.querySelector('[data-metric-id="inp"]');
    if (!card) return;

    const statusEl = card.querySelector('[data-status]');
    if (statusEl && statusEl.getAttribute('data-status') === 'pending') {
      statusEl.textContent = '인터랙션 대기 중';
    }
  }

  // 측정 상태 추적
  const measured: Record<string, boolean> = {
    lcp: false,
    inp: false,
    cls: false,
  };

  /**
   * web-vitals 콜백 핸들러
   */
  function handleMetric(metric: Metric): void {
    const metricId = metric.name.toLowerCase() as MetricId;
    const status = getMetricStatus(metricId, metric.value);
    updateMetricCard(metricId, metric.value, status);
    measured[metricId] = true;

    // 마지막 측정 시간 업데이트
    const win = window as Window & {
      setLastMeasured?: () => void;
      updateMetricScore?: (metric: string, value: number) => void;
    };
    if (win.setLastMeasured) {
      win.setLastMeasured();
    }

    // 성능 점수 업데이트
    if (win.updateMetricScore) {
      win.updateMetricScore(metricId, metric.value);
    }
  }

  // Core Web Vitals 측정 시작
  onLCP(handleMetric);
  onINP(handleMetric, { reportAllChanges: true }); // 모든 인터랙션 즉시 보고
  onCLS(handleMetric, { reportAllChanges: true }); // 레이아웃 변화 즉시 보고

  // Additional Metrics 측정 시작
  onTTFB(handleMetric);
  onFCP(handleMetric);

  // INP는 사용자 인터랙션이 필요하므로 대기 상태 표시
  setTimeout(() => {
    if (!measured.inp) {
      setInpWaiting();
    }
  }, 3000);

  // 5초 후에도 측정되지 않은 지표는 미지원 처리
  setTimeout(() => {
    if (!measured.lcp) setUnsupported('lcp');
    if (!measured.cls) setUnsupported('cls');
    // INP는 인터랙션 대기 상태 유지
  }, 5000);
</script>

<!-- Resource Analysis 스크립트 -->
<script>
  import {
    analyzeResources,
    getResourceStats,
    formatBytes,
    type ResourceSummary,
  } from '../utils/performance';

  /**
   * 리소스 카테고리별 색상
   */
  const RESOURCE_COLORS: Record<string, string> = {
    JavaScript: '#f7df1e',
    CSS: '#264de4',
    Images: '#4ade80',
    Fonts: '#a78bfa',
    Other: '#6b7280',
  };

  /**
   * 리소스 요약 렌더링
   */
  function renderResourceSummary(stats: { totalCount: number; totalSize: number }): void {
    const container = document.getElementById('resource-summary');
    if (!container) return;

    container.innerHTML = `
      <div class="summary-item">
        <div class="summary-value">${stats.totalCount}</div>
        <div class="summary-label">Total Requests</div>
      </div>
      <div class="summary-item">
        <div class="summary-value">${formatBytes(stats.totalSize)}</div>
        <div class="summary-label">Total Size</div>
      </div>
    `;
  }

  /**
   * 리소스 차트 렌더링
   */
  function renderResourceChart(resources: ResourceSummary[]): void {
    const container = document.getElementById('resource-chart');
    if (!container || resources.length === 0) return;

    const maxPercentage = Math.max(...resources.map((r) => r.percentage));

    const barsHtml = resources
      .map((r) => {
        const widthPercent = maxPercentage > 0 ? (r.percentage / maxPercentage) * 100 : 0;
        const displayPercent = (r.percentage * 100).toFixed(1);

        return `
        <div class="chart-bar-wrapper">
          <div class="chart-bar-header">
            <span class="chart-bar-label">${r.type}</span>
            <span class="chart-bar-value">${r.count}개 · ${formatBytes(r.totalSize)}</span>
          </div>
          <div class="chart-bar-track">
            <div
              class="chart-bar-fill"
              data-type="${r.type}"
              style="width: ${widthPercent}%"
            >
              <span>${displayPercent}%</span>
            </div>
          </div>
        </div>
      `;
      })
      .join('');

    container.innerHTML = `<div class="chart-container">${barsHtml}</div>`;
  }

  /**
   * 리소스 상세 카드 렌더링
   */
  function renderResourceDetails(resources: ResourceSummary[]): void {
    const container = document.getElementById('resource-details');
    if (!container) return;

    const cardsHtml = resources
      .map((r) => {
        const color = RESOURCE_COLORS[r.type] || RESOURCE_COLORS.Other;
        return `
        <div class="resource-card">
          <div class="resource-card-header">
            <div class="resource-card-icon" style="background: ${color}"></div>
            <span class="resource-card-title">${r.type}</span>
          </div>
          <div class="resource-card-stats">
            <span class="resource-card-count">${r.count} requests</span>
            <span class="resource-card-size">${formatBytes(r.totalSize)}</span>
          </div>
        </div>
      `;
      })
      .join('');

    container.innerHTML = cardsHtml;
  }

  /**
   * 리소스 분석 실행
   */
  function runResourceAnalysis(): void {
    const stats = getResourceStats();
    const resources = analyzeResources();

    renderResourceSummary(stats);
    renderResourceChart(resources);
    renderResourceDetails(resources);
  }

  // 페이지 로딩 완료 후 분석 실행
  if (document.readyState === 'complete') {
    runResourceAnalysis();
  } else {
    window.addEventListener('load', () => {
      // 약간의 지연을 두어 모든 리소스가 로드되도록 함
      setTimeout(runResourceAnalysis, 100);
    });
  }
</script>

<!-- Navigation Timing 스크립트 -->
<script>
  import {
    getNavigationTiming,
    getTotalLoadTime,
    formatDuration,
    type TimingPhase,
  } from '../utils/performance';

  /**
   * 타이밍 요약 렌더링
   */
  function renderTimingSummary(totalTime: number): void {
    const container = document.getElementById('timing-summary');
    if (!container) return;

    const entries = performance.getEntriesByType('navigation');
    if (entries.length === 0) {
      container.innerHTML = '<div class="summary-loading">타이밍 정보를 가져올 수 없습니다.</div>';
      return;
    }

    const timing = entries[0] as PerformanceNavigationTiming;
    const domContentLoaded = timing.domContentLoadedEventEnd - timing.startTime;
    const domInteractive = timing.domInteractive - timing.startTime;

    container.innerHTML = `
      <div class="timing-summary-item">
        <div class="timing-summary-value">${formatDuration(totalTime)}</div>
        <div class="timing-summary-label">Total Load Time</div>
      </div>
      <div class="timing-summary-item">
        <div class="timing-summary-value">${formatDuration(domContentLoaded)}</div>
        <div class="timing-summary-label">DOMContentLoaded</div>
      </div>
      <div class="timing-summary-item">
        <div class="timing-summary-value">${formatDuration(domInteractive)}</div>
        <div class="timing-summary-label">DOM Interactive</div>
      </div>
    `;
  }

  /**
   * 워터폴 차트 렌더링
   */
  function renderWaterfallChart(phases: TimingPhase[]): void {
    const container = document.getElementById('timing-waterfall');
    if (!container || phases.length === 0) {
      if (container) {
        container.innerHTML = '<div style="color: var(--color-text-muted); font-size: 0.9rem;">타이밍 데이터가 없습니다.</div>';
      }
      return;
    }

    // 시작 시간의 최소값 찾기
    const minStart = Math.min(...phases.map((p) => p.start));
    const maxEnd = Math.max(...phases.map((p) => p.end));
    const range = maxEnd - minStart || 1;

    const rowsHtml = phases
      .map((phase) => {
        const leftPercent = ((phase.start - minStart) / range) * 100;
        const widthPercent = Math.max((phase.duration / range) * 100, 0.5);
        const durationText = phase.duration >= 1 ? formatDuration(phase.duration) : '<1ms';

        return `
        <div class="waterfall-row">
          <div class="waterfall-label">${phase.name}</div>
          <div class="waterfall-track">
            <div
              class="waterfall-bar"
              style="left: ${leftPercent}%; width: ${widthPercent}%; background: ${phase.color}"
            >
              ${widthPercent > 8 ? `<span>${durationText}</span>` : ''}
            </div>
          </div>
          <div class="waterfall-duration">${durationText}</div>
        </div>
      `;
      })
      .join('');

    container.innerHTML = `
      <div class="waterfall-container">
        <div class="waterfall-header">
          <span>0ms</span>
          <span>${formatDuration(range)}</span>
        </div>
        ${rowsHtml}
      </div>
    `;
  }

  /**
   * 범례 렌더링
   */
  function renderTimingLegend(phases: TimingPhase[]): void {
    const container = document.getElementById('timing-legend');
    if (!container || phases.length === 0) return;

    const legendHtml = phases
      .map(
        (phase) => `
        <div class="legend-item">
          <div class="legend-color" style="background: ${phase.color}"></div>
          <span class="legend-name">${phase.name}</span>
        </div>
      `
      )
      .join('');

    container.innerHTML = legendHtml;
  }

  /**
   * Navigation Timing 분석 실행
   */
  function runNavigationTimingAnalysis(): void {
    const phases = getNavigationTiming();
    const totalTime = getTotalLoadTime();

    renderTimingSummary(totalTime);
    renderWaterfallChart(phases);
    renderTimingLegend(phases);
  }

  // 페이지 로딩 완료 후 분석 실행
  if (document.readyState === 'complete') {
    runNavigationTimingAnalysis();
  } else {
    window.addEventListener('load', () => {
      // 약간의 지연을 두어 타이밍 데이터가 완성되도록 함
      setTimeout(runNavigationTimingAnalysis, 200);
    });
  }
</script>

<style>
  .monitoring-container {
    max-width: var(--max-width-wide);
    margin: 0 auto;
    padding: 2rem 1rem;
  }

  .page-header {
    text-align: center;
    margin-bottom: 2.5rem;
  }

  .page-title {
    font-size: 2rem;
    font-weight: 700;
    color: var(--color-text);
    margin: 0 0 0.75rem;
  }

  .page-description {
    font-size: 1rem;
    color: var(--color-text-muted);
    margin: 0;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
  }

  .browser-note {
    display: block;
    font-size: 0.875rem;
    margin-top: 0.5rem;
    opacity: 0.8;
  }

  .score-section {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2rem;
    margin-top: 1.5rem;
    flex-wrap: wrap;
  }

  .overall-score {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
  }

  .score-ring {
    position: relative;
    width: 120px;
    height: 120px;
  }

  .score-ring svg {
    transform: rotate(-90deg);
    width: 100%;
    height: 100%;
  }

  .score-bg {
    fill: none;
    stroke: var(--color-border);
    stroke-width: 8;
  }

  .score-progress {
    fill: none;
    stroke: #6b7280;
    stroke-width: 8;
    stroke-linecap: round;
    stroke-dasharray: 339;
    stroke-dashoffset: 339;
    transition: stroke-dashoffset 0.8s ease, stroke 0.3s ease;
  }

  .score-value {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2rem;
    font-weight: 700;
    color: var(--color-text);
    font-family: var(--font-mono, monospace);
  }

  .score-label {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--color-text);
  }

  .score-status {
    font-size: 0.8rem;
    color: var(--color-text-muted);
  }

  .live-status {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-card);
  }

  .status-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
  }

  .status-icon {
    font-size: 1rem;
    opacity: 0.7;
  }

  .status-label {
    color: var(--color-text-muted);
  }

  .status-value {
    font-weight: 600;
    color: var(--color-text);
    font-family: var(--font-mono, monospace);
  }

  .dashboard-section {
    margin-bottom: 2.5rem;
  }

  .dashboard-section:last-child {
    margin-bottom: 0;
  }

  /* 반응형 */
  @media (max-width: 640px) {
    .monitoring-container {
      padding: 1.5rem 1rem;
    }

    .page-title {
      font-size: 1.5rem;
    }

    .page-description {
      font-size: 0.9rem;
    }

    .score-section {
      flex-direction: column;
      gap: 1.25rem;
    }

    .score-ring {
      width: 100px;
      height: 100px;
    }

    .score-value {
      font-size: 1.75rem;
    }

    .live-status {
      width: 100%;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      padding: 0.6rem 0.75rem;
    }

    .status-item {
      font-size: 0.8rem;
      gap: 0.35rem;
    }

    .status-icon {
      font-size: 0.9rem;
    }

    .dashboard-section {
      margin-bottom: 2rem;
    }
  }
</style>
